# -*- coding: utf-8 -*-
"""GPyOpt_2D_BO

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1734-oPIuH5BWT4uje1l66zXKB0vC9j3t
"""

try:
    # Check if notebook is running in Google Colab
    import google.colab
    # Install additional dependencies
    !pip install GPy #==1.9.8
    !pip install GPyOpt #==1.2.2
except:
    pass

#ASPIRIN Enter variables here (REMEMBER to change the variables if need be)

API = "aspirinAdBO"
Solvent = "ethyl acetate"
Target_GR = 0.05 #this is in um/s
Target_IT = 3600 #this is in s
Target_NR = 0.1 #this is in #/s

#LAMIVUDINE Enter variables here (REMEMBER to change the variables if need be)

API = "lamivudineBO10"
Solvent = "ethanol"
Target_GR = 0.01 #this is in um/s
Target_IT = 3600 #this is in s
Target_NR = 0.1 #this is in #/s

from google.colab import files
uploaded = files.upload()

#Creating the dataframe/ wrangling the data

import io
import pandas as pd
import numpy as np
#df = pd.read_csv(io.BytesIO(uploaded['dfBO_ASP.csv']))
xlsx = io.BytesIO(uploaded.get('Experimental Master Sheet.xlsx'))
df = pd.read_excel(xlsx, "Kinetics")
raw_df = df[(df["Solute"]==API) & (df["Solvent"]==Solvent)]
raw_df_sel = raw_df[["SS", "Isothermal Temp", "Median CB Induction Time (s)", "Mean CB Growth Rate fit to all (um/s)", "Mean CB Nucleation Rate (#/s)"]]
dropna_raw_df = raw_df_sel.dropna()
df = pd.DataFrame(dropna_raw_df)
df.insert(2, "T K/100", (df["Isothermal Temp"]+273.15)/100)
df.insert(6, "Transformed Induction Time", abs(np.log(Target_IT) - np.log(df["Median CB Induction Time (s)"])))
df.insert(6, "Transformed Growth Rate", abs(np.log(Target_GR) - np.log(df["Mean CB Growth Rate fit to all (um/s)"])))
df.insert(8, "Transformed Nucleation rate", abs(np.log(Target_NR) - np.log(df["Mean CB Nucleation Rate (#/s)"])))
df.insert(9, "Objective Function", df["Transformed Induction Time"]+df["Transformed Growth Rate"]+df["Transformed Nucleation rate"])
print(df)

#Plotting Pareto front

import matplotlib.pyplot as plt
x0 = np.ravel(df["Transformed Growth Rate"])
x1 = np.ravel(df["Transformed Induction Time"])
x = (x0, x1)
y = np.ravel(df["Transformed Nucleation rate"])
fig = plt.figure
ax = plt.axes(projection='3d')
#ax.scatter3D(xs=x[0], ys=x[1], zs = y, label="Data")
ax.stem(x=x[0], y=x[1], z=y, label="Data", basefmt=" ")
ax.set_zlim(zmin=0)
ax.invert_xaxis()
ax.set_xlabel('Transformed Growth Rate')
ax.set_ylabel('Transformed Induction Time')
ax.set_zlabel('Transformed Nucleation rate')
ax.scatter3D(xs=x0[16], ys=x1[16], zs=y[16], color="r", label="AdBO", marker="*")
ax.legend()
plt.show()

#Plotting experimental data

import matplotlib.pyplot as plt
x0 = np.ravel(df["SS"])
x1 = np.ravel(df["T K/100"])
x = (x0, x1)
y = np.ravel(df["Objective Function"])
fig = plt.figure
ax = plt.axes(projection='3d')
#ax.scatter3D(xs=x[0], ys=x[1], zs = y, label="Data")
ax.stem(x=x[0], y=x[1], z=y, label="Data", basefmt=" ")
ax.set_zlim(zmin=0)
ax.set_xlabel('SS')
ax.set_ylabel('T /K/100')
ax.set_zlabel('Objective function')
plt.show()

#Creating initial value variables from df

z_init = df[["Objective Function"]].to_numpy()
xy_init = df[["SS","T K/100"]].to_numpy()

# ASPIRIN Optimisation/ suggested next location

import time
import GPyOpt
from GPyOpt.methods import BayesianOptimization
from numpy.random import seed
seed(123)

start_time = time.time()

def f(x,y):
    return x**2 + x + y**2 + y

#Don't forget to change the bounds relative to each API (just SS)
bounds = [{'name': 'SS', 'type': 'continuous', 'domain': (1.05, 2)},
          {'name': 'T', 'type': 'continuous', 'domain': (2.7815, 3.2315)}]

bo_step = GPyOpt.methods.BayesianOptimization(f = f,
                                              domain=bounds,
                                              model_type='GP',
                                              acquisition_type ='EI',
                                              acquisition_jitter = 0.0000000000000000000000000000000000000000001,
                                              X=xy_init,
                                              Y=z_init)

x_next = bo_step.suggest_next_locations()

print("Value of (x,y) that next should be evaluated to minimize the objective func: "+str(x_next))

bo_step.plot_acquisition()

print("--- %s seconds ---" % (time.time() - start_time))

# LAMIVUDINE Optimisation/ suggested next location

import time
import GPyOpt
from GPyOpt.methods import BayesianOptimization
from numpy.random import seed
seed(123)

start_time = time.time()

def f(x,y):
    return x**2 + x + y**2 + y

#Don't forget to change the bounds relative to each API (just SS)
bounds = [{'name': 'SS', 'type': 'continuous', 'domain': (2, 3)},
          {'name': 'T', 'type': 'continuous', 'domain': (2.7815, 3.2315)}]

bo_step = GPyOpt.methods.BayesianOptimization(f = f,
                                              domain=bounds,
                                              model_type='GP',
                                              acquisition_type ='EI',
                                              acquisition_jitter = 0.0000000000000000000000000000000000000000001,
                                              X=xy_init,
                                              Y=z_init)

x_next = bo_step.suggest_next_locations()

print("Value of (x,y) that next should be evaluated to minimize the objective func: "+str(x_next))

bo_step.plot_acquisition()

print("--- %s seconds ---" % (time.time() - start_time))

#Co-variance matrix in respect to objective function
import numpy as np
import seaborn as sn
import matplotlib.pyplot as plt

S = np.ravel(df["SS"])
T = np.ravel(df["T K/100"])
O = np.ravel(df["Objective Function"])

data = np.array([S, T, O])

cov_matrix = np.cov(data,bias=True)
sn.heatmap(cov_matrix, annot=True, fmt='g')
plt.show()

#Co-variance matrix in respect to each variable (not-normalised)
import numpy as np
import seaborn as sn
import matplotlib.pyplot as plt

S = np.ravel(df["SS"])
T = np.ravel(df["T K/100"])
I = np.ravel(df["Median CB Induction Time (s)"])
G = np.ravel(df["Mean CB Growth Rate fit to all (um/s)"])
N = np.ravel(df["Mean CB Nucleation Rate (#/s)"])

data = np.array([S, T, I, G, N])

cov_matrix = np.cov(data,bias=True)
sn.heatmap(cov_matrix, annot=True, fmt='g')
plt.show()

#Plot of objective function with each iteration
#xn = list(range(0,11))
O = np.ravel(df["Objective Function"])
desO = np.sort(O)[::-1]
xn = list(range(0,len(O)))
plt.xlabel("Number of experiments")
plt.ylabel("Objective function")
plt.plot(xn,desO)

#Reduction (of objective function)
O = np.ravel(df["Objective Function"])
HPRed = (max(O)/min(O))*100
HPRed2 = (min(O)/max(O))*100
print(HPRed)
print(HPRed2)

normalized_df=(df-df.min())/(df.max()-df.min())
#Co-variance matrix in respect to each variable (normalised)
import seaborn as sn
cov_df = normalized_df[["SS", "T K/100", "Median CB Induction Time (s)", "Mean CB Growth Rate fit to all (um/s)", "Mean CB Nucleation Rate (#/s)"]]
sn.heatmap(cov_df.corr(), annot=True, fmt='.3f')

normalized_df=(df-df.min())/(df.max()-df.min())
#Co-variance matrix in respect to each variable (normalised)
#import seaborn as sn
#import numpy as np
#import matplotlib.pyplot as plt
#OLD CODE
'''S = np.ravel(normalized_df["SS"])
T = np.ravel(normalized_df["T K/100"])
I = np.ravel(normalized_df["Median CB Induction Time (s)"])
G = np.ravel(normalized_df["Mean CB Growth Rate fit to all (um/s)"])
N = np.ravel(normalized_df["Mean CB Nucleation Rate (#/s)"])

data = np.array([S, T, I, G, N])

cov_matrix = np.cov(data,bias=True)
sn.heatmap(cov_matrix, annot=True, fmt='.3f')
plt.show()'''